name: Check security alerts

on:
  schedule:
  - cron: "30 1 * * *"
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVE_TOKEN }}
          script: |
            if (!'${{secrets.SECURITY_ISSUE_REPO}}')
               return;

            const { owner, repo } = context.repo;

            const states = {
              open:   'open',
              closed: 'closed',
            };

            const labels = {
              dependabot: 'dependabot',
              codeq:      'codeql',
              security:   'security notification',
            };

            const dependabotAlerts      = await getDependabotAlerts();
            const codeqlAlerts          = await getCodeqlAlerts();
            const {data: existedIssues} = await github.rest.issues.listForRepo({ 
              owner, 
              repo:   '${{ secrets.SECURITY_ISSUE_REPO }}', 
              labels: [labels.security], 
              state:  states.open, 
            });

            const alertDictionary = existedIssues.reduce((res, issue) => {
              const [,url, number] = issue.body.match(/Link:\s*(https.*?(\d+)$)/);

              if (!url)
                return res;

              res[url] = {
                issue, number,
                isDependabot: url.includes('dependabot'),
              };

              return res;
            }, {})

            for (const key in alertDictionary) {
              var alert = alertDictionary[key];

              if (alert.isDependabot) {
                const isAlertOpened = await isDependabotAlertOpened(alert.number);

                if (isAlertOpened)
                  continue;
                  
                await closeIssue(alert.issue.number)
              }
            }

            dependabotAlerts.forEach(alert => {
              if (!needCreateIssue(alert))
                return;

              createIssue({
                labels:      [labels.dependabot, labels.security, alert.dependency.scope], 
                originRepo:  repo,
                summary:     alert.security_advisory.summary, 
                description: alert.security_advisory.description, 
                link:        alert.html_url, 
                package:     alert.dependency.package.name
              })
            });

            codeqlAlerts.forEach(alert => {
              if (!needCreateIssue(alert))
                return;

              createIssue({
                labels:      [labels.codeql, labels.security], 
                originRepo:  repo,
                summary:     alert.rule.description, 
                description: alert.most_recent_instance.message.text, 
                link:        alert.html_url, 
              })
            });

            async function getDependabotAlerts () {
              const { data }  = await github.rest.dependabot.listAlertsForRepo({ owner, repo, state: states.open });

              return data;
            }

            async function getCodeqlAlerts () {
              try {
                const { data }  = await github.rest.codeScanning.listAlertsForRepo({ owner, repo, state: states.open });

                return data;
              } catch (e) {
                if (e.message.includes('no analysis found'))
                  return [];

                throw e;
              }
            }

            async function isDependabotAlertOpened (alertNumber) {
              const alert = await getDependabotAlertInfo(alertNumber);

              return alert.state === states.open;
            }

            async function getDependabotAlertInfo (alertNumber) {
              try {
                const { data } = await github.rest.dependabot.getAlert({ owner, repo, alert_number: alertNumber });

                return data;
              } catch (e) {
                if (e.message.includes('No alert found for alert number'))
                  return {};

                throw e;
              }
            }

            function needCreateIssue (alert) {
              return !alertDictionary[alert.html_url]
                    && Date.now() - new Date(alert.created_at) <= 1000 * 60 * 60 * 24;
            }

            async function createIssue ({labels, originRepo, summary, description, link, package = ''}) {
              const title = `[${originRepo}] ${summary}`;
              const body  = ''
                + `#### Repository: \`${ originRepo }\`\n`
                + (!!package ? `#### Package: \`${ package }\`\n` : '')
                + `#### Description:\n`
                + `${ description }\n`
                + `#### Link: ${ link }`

              return github.rest.issues.create({ 
                owner, title, body, labels,
                repo: '${{ secrets.SECURITY_ISSUE_REPO }}',
              });
            }

            async function closeIssue (issueNumber) {
              return github.rest.issues.update({ 
                owner, 
                repo:         '${{ secrets.SECURITY_ISSUE_REPO }}', 
                issue_number: issueNumber, 
                state:        states.closed 
              });
            }